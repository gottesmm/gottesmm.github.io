---
layout: page
title: Proposal for adding No Escaping Arguments, Move Only Values, and Move Only Types to Swift
categories: draft
---

This document contains a proposal to add three features into Swift:

* No escaping arguments
* Move only values
* Move only types

The general outline of our discussion will be:

1. We begin by talking about how move only values are naturally represented in
   SIL when in Ownership SSA (OSSA) form, the type system at the SIL level,
   introduce the notion of a unique value, and conclude by contrasting Copy on
   Write (COW) uniqueness with the uniqueness implied by a ``unique value``.

2. Then we will talk about how the structure of SILGen today forces copies to be
   emitted in many contexts creating one of the main problems of the bringup
   that we need to solve and how a a new diagnostic pass called **Diagnostic
   Copy Propagation** enabled by Ownership SSA will enable us to work around
   these issues and achieve our goal of move only types without rewriting
   SILGen.

3. Then we will conclude by outlining a bring up plan that will allow for
   incremental development of **Diagnostic Copy Propagation** through the
   implementation of several features that we already want to add to Swift.

## Representing Move Only Values in SIL

**NOTE:** In the following I am assuming that one has read the [Ownership SSA documentation](https://github.com/apple/swift/blob/main/docs/SIL.rst#id42) in SIL.rst.

**NOTE:** In the following section, I am going to use a straw man type attribute
(`@move`) to signal that a value (even if normally not move only) is move
only. Later on I will introduce a new name `unique` at the end of the section
for `@move` when I talk about type system aspects.

In the following, I first discuss the natural form for representing move only
values in SIL. Then I talk about how we extend this model from non-trivial
loadable values to trivial loadable values and address only types. Finally I
conclude about how `unique` classes and move only fields affect the properties
of aggregate types in SIL and the result that we call our move only values
"unique values".

#### Move Only Values in OSSA

In order for us to represent move only values, we need to first consider what
their form looks like in SIL. Put simply copies in SIL are represented via
special instructions (e.x.: `copy_value`) and a move only value in SIL is a SSA
value that is never passed to such an instruction. Instead, we manipulate the
value around using forwarding instructions and consuming parameters. Example:

```
sil @move_only_value_example : $@convention(thin) (@owned @move Optional<Klass>) -> () {
bb0(%0 : @owned $@move Optional<Klass>):
  // Inserting a copy_value of %0 will cause the IR verifier to assert!
  switch_enum %0 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2

bb1(%1 : @owned $@move Klass):
  %f = function_ref @myFoo2 : $@convention(thin) (@owned @move SubKlass) -> ()
  %2 = unchecked_ref_cast %1 : $@move Klass to $@move SubKlass
  apply %f(%2) : $@convention(thin) (@owned @move SubKlass) -> ()
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}
```

Naturally, one would in Ownership SSA form ban any value of such a type being an
operand to any copy instruction, guaranteeing the property that we wish to
preserve.

For memory, we can use a similar methodology, banning instructions like
``copy_addr`` from copying a "move only value". Example:

```
sil @move_only_value_memory_example : $@convention(thin) (@owned @move Optional<Klass>) -> () {
bb0(%0 : @owned $@move Optional<Klass>):
  %1 = alloc_stack $@move Optional<Klass>
  // Store using a move...
  store %0 to [init] %1 : $*@move Optional<Klass>
  // load [take] is legal here. A load [copy] would be illegal and would cause the IR
  // verifier to assert.
  %3 = load [take] %1 : $*@move Optional<Klass>
  store %3 to [init] %1 : $*@move Optional<Klass>
  %2 = alloc_stack $@move Optional<Klass>
  // IR verifier would assert if this did not have a [take].
  copy_addr [take] %1 to [initialization] %2 : $*@move Optional<Klass>
  ...
}
```

#### Modeling Address Only and Trivial Move Only Values

The model above naturally flows from how non-trivial loadable values are
represented in OSSA. That being said, we must consider two other types of values
that do not fit into that bucket today but that we must support: address only
values and trivial loadable values.

* Address Only Move Only Values. Since we want to fully take advantage of
Ownership SSA and its invariants, we naturally will rely upon opaque values to
ensure that beyond temporaries generated by SILGen, move only values will be
passed around as loadable values:

```
sil [ossa] @opaque_value_move_only : $@convention(thin) <T> (@in @move T) -> @out @move T {
bb0(%0 : @owned $@move T):
  %3 = function_ref @opaque_copy : $@convention(thin) <T> (@in_guaranteed @move T) -> @out @move T
  %4 = apply %3<T>(%2) : $@convention(thin) <T> (@in_guaranteed @move T) -> @out @move T
  destroy_value %0 : $T
  return %4 : $T
}
```

* Trivial Move Only Values: In order for us to represent trivial move only
values in SIL, we must work around the invariant in SIL that only non-trivial
values can be copied. In order to prevent breaking these invariants, we will
introduce a new SIL instruction that can be used to convert a trivial value into
a non-trivial value by adding the ``@move`` attribute to the type. As a straw
man (since we have not talked about `unique` yet), we will call the instruction
``make_move_only`` in the following example. In order to ensure that we do not
hurt performance, we will lower away the ``make_move_only`` instruction when we
lower Ownership SSA allowing for normal optimization of trivial values to
occur. Example:

```
sil [ossa] @trivial_value_move_only : $@convention(thin) (Int) -> () {
bb0(%0 : $Int):
  // %1 is a non-trivial value of type $@move Int
  %1 = make_move_only %0 : $Int

  %f = function_ref @trivial_use : $@convention(thin) (Int) -> ()
  // We can only pass %0 (not %1) to %f since %f expects an Int, not an @move Int.
  apply %f(%0) : $@convention(thin) (Int) -> ()

  %f2 = function_ref @trivial_move_only_use : $@convention(thin) (@owned @move Int) -> ()
  // We can pass both %0 and %1 to %f2 since we allow for $Int to be passed as an @owned @move Int value.
  apply %f2(%0) : $@convention(thin) (@owned @move Int) -> ()
  apply %f2(%1) : $@convention(thin) (@owned @move Int) -> ()
  ...
}
```

By using opaque values and the ``make_move_only`` instruction, we are able to
recast introducing move only values for these two sorts of values in terms of
non-trivial loadable values simplifying the implementation.

#### Move Only Values, Aggregates, and Unique Classes

In SIL, all aggregates (e.x.: struct, tuple, enum) have properties that flow up
from the fields of the aggregate to the parent aggregate type to enable
composition. As an example, an aggregate that contains an address only type or a
non-trivial type must itself be an address only type or non-trivial type
respectively. The notion of being "move only" must follow a similar scheme.

To explore this, consider what a "move only" class would be. Naturally a "move
only" class in SIL must be a class that can never be copied implying that the
class must always be "unique" (i.e.: have a reference count of 1) at all program
points. Such a class we call a ``unique`` class.

**NOTE:** We are using ``unique`` in a different sense than the way ``unique``
has typically been used in Swift with reference to COW types. See [Unique Values
vs Unique COW Values](#discussion-unique-values-vs-unique-cow-values) below for
a discussion of the differences in between the two concepts.

Lets now consider a ``struct`` that contains a ``unique class``:

```
unique class MyKlass { ... }

struct MyKlassWrapper {
  let k: MyKlass
}
```

the natural property that ``MyKlassWrapper`` must preserve in order for
``MyKlass`` to maintain its uniqueness property is that ``MyKlassWrapper`` too
must never be copied at the SIL level since copying an aggregate in SIL is
equivalent to copying each of its underlying fields. Thus we must conclude that
any aggregate that contains a ``unique class`` must also be move only to ensure
that the ``unique class`` property its preserved. Such a value we call a
``unique value`` and mark it with the ``unique`` keyword:

```
unique class MyKlass { ... }

unique struct MyKlassWrapper {
  let k: MyKlass
}
```

If one follows this definition recursively, easily any aggregate that contains a
``unique value`` must also be unique. Importantly that restriction does not
propagate downwards through the type tree since a non-unique value contained
within a unique aggregate can always be moved when the aggregate is moved as
well.

**NOTE:** Form here on in this proposal, rather than using the term "move only",
we will use the term "unique".

#### Discussion: Unique Values vs Unique COW Values

One source of confusion that has occurred in discussions around unique values is
their relationship with unique COW values. To put it simply, a value being
unique in a value sense is a stricter condition than uniqueness in terms of Copy
On Write. As an example, a unique COW type is allowed to be escape into an
unknown function that retains/releases the COW type as long as after we return
from the function, the COW type is again unique. In contrast, a ``unique value``
must be guaranteed to never have its reference count touched in the callee
function. Importantly this means that if we transition COW types to model
uniqueness using unique value semantics, we do not break ABI requirements since
when we recompile code to use the new unique semantics, the stricter uniqueness
properties will ensure that upon return from a callee, uniqueness is always
preserved.

## SILGen, the "Ensure Plus One Problem", and Copying Unique Values

#### Problem Statement

A characteristic of SILGen today is that parts of SILGen have been written to
assume +0 and others +1 values causing SILGen to have to transition in between
such contexts. The natural way to do so is to introduce additional copies into
the IR using APIs such as ManagedValue::ensurePlusOne() or creating new
ManagedValues without cleanups. This creates a significant problem for bringing
up move only types since without significant engineering work, we /cannot/
guarantee that SILGen will not insert copies on a move only value, directly
conflicting with the design of move only types at the SIL level that we want to
achieve as described above. Instead, we must be creative and come up with a
different approach to solve our problem that /works around/ SILGen's current
behavior. Luckily for us a recent technical advance in OSSA SIL can help us to
escape from our predicament: Copy Propagation.

#### Copy Propagation

As a result of implementing Ownership SSA (OSSA) in SIL, the Swift compiler can
now infer correct lifetimes at compile time of loadable typed values based off
of the SSA uses of that value. The inferred lifetimes are able to be statically
verified by the compiler as being OSSA correct (1) and allows the compiler to
guarantee that a programs ARC traffic will be the local minimal set of
operations needed to express the programs semantics. This is done by finding all
of the places where the value has lifetime ending uses (consuming uses) and then
determining the appropriate places where a copy would be needed if a lifetime
ending use is reachable from another lifetime ending use. These are exactly the
places where a programmer would need to manually insert an explicit copy when
using a move only type! This transformation is called **Copy Propagation** and
is currently implemented just for optimization purposes in a SILOptimizer pass
called **Performance Copy Propagation**. To get a visual sense of how this pass
works in action, see the section below called [Performance Copy Propagation in
Action](#reference-performance-copy-propagation-in-action).  The authors believe
with a little bit of work, rather than re-implementing a large part of SILGen,
we can take advantage of this technique to implement move only types despite
SILGen by:

* Allowing for move only values to be copied in Raw SIL by instructions like
  ``copy_value``.

* Still banning values from being copies using memory instructions like
  ``copy_addr``/``load [copy]``. This simplifies the problem and will force
  copies to always be emitted at the value level (that is a ``load [take]`` +
  ``copy_value`` would still be legal. This simplifies the problem.

* Introducing a new SIL instruction called ``explicit_copy_value``. This will
  ensure that the user can if they so choose emit an explicit copy without
  breaking the move only property of the IR.

* Implementing a new diagnostic pass called **Diagnostic Constant Propagation**
  that uses the copy propagation infrastructure to rewrite all copies of such
  values and emit diagnostics when we would need to insert copies. The pass
  would know the specific uses that caused the copy to be needed and would be
  able to emit an error/fixit at the place where the copy would be needed. The
  fixit if used would cause an ``explicit_copy_value`` instruction to be used at
  that place ensuring legality.

* Once **Diagnostic Constant Propagation** has run, all move only types will be
  guaranteed to only be copied by ``explicit_copy_value`` instructions.

* Finally, once we are in Canonical SIL (after all diagnostic passes have run),
  we will then enforce the IR constraints via the verifier that a ``copy_value``
  can never be used on a move only value.

This will provide a flexible implementation that will let us achieve our goals
for being able to represent a value that is never copied without needing to
rewrite large parts of SILGen.

## The Bringup Plan

Now that we have a methodology for accomplishing our goals, the natural question

**JOEG/ANDY END OF INITIAL PART**

## Reference: Performance Copy Propagation in Action

Lets look through a few examples of how performance constant propagation works
to get a sense of how this works at the SIL level. Consider the following SIL:

```
class Klass {}

sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Optional<Klass>):
  %1 = copy_value %0 : $Optional<Klass>
  switch_enum %1 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)

bb1(%2 : @owned $Klass):
  %f = function_ref @myFoo2 : $@convention(thin) (@guaranteed SubKlass) -> ()
  %3 = unchecked_ref_cast %2 : $Klass to $SubKlass                                      (B)
  apply %f(%3) : $@convention(thin) (@guaranteed SubKlass) -> ()
  destroy_value %3 : $Klass                                                             (C)
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}
```

PCP as it runs visits the transitive def-use graph rooted at ``%0`` looking
through uses that forward ownership from their operands to results ((A),
(B)). It sees that the only true consuming use of %0 is actually the
`destroy_value` (C) and additionally that all of the forwarding uses are able to
take a guaranteed value meaning no copies are needed. It then converts the SIL
to use guaranteed values and eliminates all of the old copies, yielding the
following SIL:

```
sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Optional<Klass>):
  switch_enum %0 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)

bb1(%1 : @guaranteed $Klass):
  %f = function_ref @myFoo2 : $@convention(thin) (@guaranteed SubKlass) -> ()
  %2 = unchecked_ref_cast %1 : $Klass to $SubKlass                                      (B)
  apply %f(%2) : $@convention(thin) (@guaranteed SubKlass) -> ()
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}
```

Lets now consider a case where we actually need a copy due to a consuming use:

```
sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Optional<Klass>):
  %1 = copy_value %0 : $Optional<Klass>
  switch_enum %1 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)

bb1(%2 : @owned $Klass):
  %f = function_ref @myFoo2 : $@convention(thin) (@owned SubKlass) -> ()
  %3 = unchecked_ref_cast %2 : $Klass to $SubKlass                                      (B)
  apply %f(%3) : $@convention(thin) (@owned SubKlass) -> ()                             (C)
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}
```

In this case, PCP will again ignore the ``copy_value`` in ``%1`` and will
compute directly from the uses that a copy is needed at (C). But it will see
that it is only needed in bb1, not along bb2. So it will insert a copy_value at
(C) and then eliminate the ``copy_value``, yielding the following SIL:

```
sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Optional<Klass>):
  switch_enum %1 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)

bb1(%2 : @guaranteed $Klass):
  %f = function_ref @myFoo2 : $@convention(thin) (@owned SubKlass) -> ()
  %3 = unchecked_ref_cast %2 : $Klass to $SubKlass                                      (B)
  %4 = copy_value %3 : $SubKlass
  apply %f(%4) : $@convention(thin) (@owned SubKlass) -> ()                             (C)
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}
```

As a final case, lets consider a situation where we need multiple copies:

```
sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Optional<Klass>):
  %1 = copy_value %0 : $Optional<Klass>
  switch_enum %1 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)

bb1(%2 : @owned $Klass):
  %f = function_ref @myFoo2 : $@convention(thin) (@owned SubKlass) -> ()
  %3 = unchecked_ref_cast %2 : $Klass to $SubKlass                                      (B)
  apply %f(%3) : $@convention(thin) (@owned SubKlass) -> ()                             (C)
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}
```

One part of the discussion below is the proposal to take advantage of this to
create a new diagnostic pass based off of the same infrastructure as
"performance copy propagation" (PCP), but instead of inserting copies, emits a
diagnostic that tells the user about why the copy was needed and as a fixit,
where the copy needs to be inserted. This would then make it very easy for the
programmer to insert an explicit copy if needed and go on with their day. This
theoretical pass I am going to refer to as "Diagnostic Copy Propagation" (DCP).



<!--

By representing move only values as SIL values in Ownership SSA form that can
never be copied, we are guaranteed via IR invariants that the optimizer will
respect the move only semantics of such a value and thus ensure

In OSSA SIL, we represent copies via the `copy_value` instruction and moves as 

Today SIL is always emitted by SILGen in OSSA form. SIL when in OSSA form
categorizes all values into belonging to an ontology of various ownership
kinds. For more information about this,

a non-trivial value's ownership invariants are enforced
statically at compile time by the IR itself. These enforced OSSA invariants
allow for the compiler to perform a proof when ever SIL is in OSSA form that the
SIL is "Ownership Correct". This means that all non-trivial values in the
verified SIL are never leaked, are never consumed twice, and only have
non-consuming uses within its actual lifetime. In this model

* The value is never leaked
* Is never consumed twice.
* Only has uses within its actual lifetime.

This is done by mandating that all non-trivial values must be able to split
their uses into a set of non-lifetime ending and lifetime ending uses. We
represent moves in this model as a consuming use of an owned value. In order to
change the form of such an owned value, we allow for a notion of what is called
a "forwarding" instruction that takes in an owned value as its operand
(consuming it), transforms the value, and then produces a new owned
value. Example:

```

```

Moves in this model are represented via the notion of a forwarding 








































































## Introduction: Diagnostic Copy Propagation

As a result of implementing Ownership SSA (OSSA) in SIL, the Swift compiler can
now infer the lifetimes at compile time of loadable typed values based off of
the SSA uses of that value. The inferred lifetimes are able to be statically
verified by the compiler as being OSSA correct (1) and allows the compiler to
guarantee theoretically minimal ARC traffic. This is done by finding all of the
places where the value has lifetime ending uses (consuming uses) and then
determining the appropriate places where a copy would be needed if a lifetime
ending use is reachable from another lifetime ending use. These are exactly the
places where a programmer would need to manually insert an explicit copy when
using a move only type! Today we use this technique in an optimization pass
called Performance Copy Propagation that given a value, ignores all current
local copies, computes/inserts the minimal set of actual copies needed and
deletes all of the old local copies. Lets take a look at some SIL examples to
see how PCP works. Consider the following SIL:

```
class Klass {}

sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Optional<Klass>):
  %1 = copy_value %0 : $Optional<Klass>
  switch_enum %1 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)

bb1(%2 : @owned $Klass):
  %f = function_ref @myFoo2 : $@convention(thin) (@guaranteed SubKlass) -> ()
  %3 = unchecked_ref_cast %2 : $Klass to $SubKlass                                      (B)
  apply %f(%3) : $@convention(thin) (@guaranteed SubKlass) -> ()
  destroy_value %3 : $Klass                                                             (C)
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}
```

PCP as it runs visits the transitive def-use graph rooted at ``%0`` looking
through uses that forward ownership from their operands to results ((A),
(B)). It sees that the only true consuming use of %0 is actually the
`destroy_value` (C) and additionally that all of the forwarding uses are able to
take a guaranteed value meaning no copies are needed. It then converts the SIL
to use guaranteed values and eliminates all of the old copies, yielding the
following SIL:

```
sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Optional<Klass>):
  switch_enum %0 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)

bb1(%1 : @guaranteed $Klass):
  %f = function_ref @myFoo2 : $@convention(thin) (@guaranteed SubKlass) -> ()
  %2 = unchecked_ref_cast %1 : $Klass to $SubKlass                                      (B)
  apply %f(%2) : $@convention(thin) (@guaranteed SubKlass) -> ()
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}
```

Lets now consider a case where we actually need a copy due to a consuming use:

```
sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Optional<Klass>):
  %1 = copy_value %0 : $Optional<Klass>
  switch_enum %1 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)

bb1(%2 : @owned $Klass):
  %f = function_ref @myFoo2 : $@convention(thin) (@owned SubKlass) -> ()
  %3 = unchecked_ref_cast %2 : $Klass to $SubKlass                                      (B)
  apply %f(%3) : $@convention(thin) (@owned SubKlass) -> ()                             (C)
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}
```

In this case, PCP will again ignore the ``copy_value`` in ``%1`` and will
compute directly from the uses that a copy is needed at (C). But it will see
that it is only needed in bb1, not along bb2. So it will insert a copy_value at
(C) and then eliminate the ``copy_value``, yielding the following SIL:

```
sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Optional<Klass>):
  switch_enum %1 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)

bb1(%2 : @guaranteed $Klass):
  %f = function_ref @myFoo2 : $@convention(thin) (@owned SubKlass) -> ()
  %3 = unchecked_ref_cast %2 : $Klass to $SubKlass                                      (B)
  %4 = copy_value %3 : $SubKlass
  apply %f(%4) : $@convention(thin) (@owned SubKlass) -> ()                             (C)
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}
```

As a final case, lets consider a situation where we need multiple copies:

```
sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
bb0(%0 : @guaranteed $Optional<Klass>):
  %1 = copy_value %0 : $Optional<Klass>
  switch_enum %1 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)

bb1(%2 : @owned $Klass):
  %f = function_ref @myFoo2 : $@convention(thin) (@owned SubKlass) -> ()
  %3 = unchecked_ref_cast %2 : $Klass to $SubKlass                                      (B)
  apply %f(%3) : $@convention(thin) (@owned SubKlass) -> ()                             (C)
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}
```

One part of the discussion below is the proposal to take advantage of this to
create a new diagnostic pass based off of the same infrastructure as
"performance copy propagation" (PCP), but instead of inserting copies, emits a
diagnostic that tells the user about why the copy was needed and as a fixit,
where the copy needs to be inserted. This would then make it very easy for the
programmer to insert an explicit copy if needed and go on with their day. This
theoretical pass I am going to refer to as "Diagnostic Copy Propagation" (DCP).



(1) Ownership SSA correct means that the loadable value is guaranteed to never
be consumed twice, leaked, and all uses of the value are within the OSSA
lifetime.

----

Attendees: TimK, JohnMc, JoeG, DougG, MichaelG

DougG, JohnMc brought up that the two parts of concurrency that overlap are unique classes and mutable if unique classes.

MichaelG then laid out the discussions that we have been having. He first brought up the overall plan that we have been discussing in the Swift performance team:

1. Begin with No Escape Parameters
2. Then do Unique Values/Unique Values
3. Then with time do Unique Types

We will go through the individual discussions below on each section. Some context information is included above those other sections in order to provide context for the reader. Also note that we are assuming that we are working in a world where opaque values exist, so we do not need to worry about handling address only types.

Context: Diagnostic Copy Propagation


No Escape Parameters

#### Design

The overall proposal here was to allow for no-escape to be added to all parameters (instead of just function types). This would be implemented by adding a new diagnostic pass that would:

1. Emit an error diagnostic whenever a non-escape parameter was stored into memory.
2. Allow for trivial parameters to be passed to anything. There is no reason to restrict no escape parameters of trivial values since they are passed by value.
3. For non-trivial parameters, use a form of diagnostic copy propagation to perform the diagnostic. An owned non-trivial value will only be considered to escape if there are multiple consuming uses along the same path of the non-trivial value implying a copy would have been needed and would escape. A guaranteed non-trivial value is likewise only considered to escape if copy propagation found any consuming uses and wanted to insert copies for them. This would enable us to give really nice diagnostics that show the user what caused the escaping use. Additionally we would only allow for this value to be passed as no escape parameters.

#### Response

The end response from the group was that this was a sound idea that we want to pursue as part of this effort.

There were some questions around if we needed to use diagnostic copy propagation/connect this directly with move only value implementation. It was noted that we want no-escape to also work for trivial values like UnsafePointer. We want to prevent people from escaping these pointers from withUnsafePointer closures. The design here will need to be modified to take this into consideration. JohnMc and MikeG agreed that this would just mean a diagnostic pass that looked at uses which is really standard/simple. We would then just loosen the rules over time as people use the feature and we find patterns for trivial types that we are ok with. We could do something similar for non-trivial values by just doing the standard thing in these types of passes: looking through copies as we walk from def→use. We would require that the value is passed only as a no-escape function argument, providing a transitive guarantee. The author (MikeG) thinks this pass design is reasonable and is pretty standard/easy thing to do with a transitive def→use traversal. We also may want to consider adding a way to escape the ‘prison’ for library writers. I think it would just be a node on the def→use traversal.

We also spoke about how this composes with move only values vs unique values. JohnMc noted that a unique value and a move only value behave differently in this model. I talk about it below in the section around move only values/unique values since I believe we were actually talking about different notions of “unique”.

*Conclusion*: But overall, we agreed it was a diagnostic pass that we believe that we could write easily and that it would be useful to people.

*From The Author:* Thanks JohnMc for the great discussion! Part of the reason that the author brought up no escape parameters, was that he thought it would help us prove that copy propagation can be used as a diagnostic in a simpler situation than with move only values. The author was trying to come up with a design program that would help us tip-toe our toes into using copy propagation for diagnostics for the first time! That being said, the escape analysis thing is still something we should do and our users will be notice it!

Unique Values and Unique Value

As a quick online of this section, I start by describing the design from the SIL level up and hopefully show how SIL level constraints pushes us towards a certain design for move only values. Then I will show how I can use Ownership SSA and Diagnostic Copy Promotion to avoid us needing to do a large update to SILGen. Then, I will talk about how we can handle trivial move only types by using an introducer and conclude by talking about how unique types can fit into all of this/how they are different than COW uniqueness (but complementary).

The natural way to represent a move only value in SIL is as a non-trivial loadable value that can not be copied with a normal copy_value. This is because in SIL the notion of being copied is inherently tied to a value being non-trivial since we do not track ownership for trivial values. The ownership of the non-trivial value flows through the entire SIL program via the def→use graph and thus we can write a diagnostic pass based off of copy propagation to infer if a copy is needed somewhere in the program and give a fixit to the user at that spot to insert an explicit copy if they want:

sil @move_only : $@convention(thin) (@owned @move Klass, @guaranteed @move Klass) -> () {
bb0(%0 : @owned @move Klass, %1 : @guaranteed @move Klass):
  // Safe, can never be copied.
  apply %f(%0) : $@convention(thin) (@guaranteed @move Klass) -> ()
  // This is an explicit copy that copy propagation left alone. We treat it as
  // a TrivialUse (meaning an ignorable one) that produces an owned value.
  %3 = explicit_copy %0
  // Error! Diagnostic constant propagation says we need a copy here.
  // Display fixit telling the user that a copy is needed here due to use at SourceLoc()
  apply %f2(%1) : $@convention(thin) (@owned @move Klass) -> ()
  // No error, we are passing off our value, moving it.
  apply %f3(%0) : $@convention(thin) (@owned @move Klass) -> ()
  // Error! Diagnostic Propagation knows %0 was already destroyed by %f2. We 
  // emit as part of the fixit that we need to put our copy before the call to %f3.
  apply %f4(%0) : $@convention(thin) (@owned @move Klass) -> ()
}

This model will make the life of programmers easier since we are not just throwing an error, we are also telling them actionable information to fix the issue!

This looks pretty, but as anyone who has worked in SILGen will tell you, SILGen loves to insert copies! In fact often times SILGen will assume that a value is at +0 to conditionally run at all. All of those places would need to be fixed and it would take time to do so. We could do that 

That all looks nice and good, but as anyone who has worked in SILGen will tell you, SILGen loves to insert copies and a lot of code triggers off of whether or not one is tracking a copy or not. Updating SILGen to support move only types out of the gate will be a lot of work and will require reimplementing/modifying a bunch of SILGen. This is something we can do, but it would be a significant amount of work. Instead, we propose that we:

1. Require move only values to be non-trivial


The author 

in SIL a move only type should naturally be represented as a non-trivial loadable value. By using the information in Ownership SSA, we can easily infer if/where a copy would be needed just based off of the uses of the value. This information is only based off the uses.

for loadable non-trivial values, a class is a very fundamental type. Beyond a class, only class bound protocols are loadable (with time address only types will be as well.. but that is once opaque values lands).

Thus if one wanted to design a notion of a move only type in SIL, it is natural to want to build it on top of non-trivial loadable unique types which are defined as values whose class fields are all unique classes. This would ensure that one could move around the class parts as a move only value and preserve the uniqueness of memory. It flows well with how SIL would want to represent these, as aggregate values. 

a unique class is a class that can never be copied, it can only be moved.

In the SIL type system classes are a foundational type of non-trivial type but there are others. For now since we are assuming that we will not allow for this on generic types until opaque values lands so one will not be able to use this with generics since we specialize code at the SIL level. So, thus any value we are talking about right now are loadable values. Then define a unique loadable value as a non-trivial loadable value that only contains unique non-trivial values. In this model, one would be able to move the value around as a move only value just as if one had a class ensuring that all of the memory structurally is unique. Even better, by taking advantage of Ownership SSA and Diagnostic Copy Propagation, we would be able to emit good diagnostics that explain to the user why the copy is needed and can provide a fixit at the appropriate place in the code where the copy would be needed. This would make working with this system much easier for the programmer. We could also identify explicit copies that were unneeded and provide a fixit to remove the copy. This will create a model where the compiler helps the user work with their code explicitly based off of the uses of the program.

The author then said, well we could bootstrap 

Specifically, a unique value is /ok/ with being copied as long as before the function ends the value is again unique. So in a sense the move only condition is a stronger condition on the def→use graph than the unique condition on values. The author believes upon reflection that the truth is that we were talking about two different forms of uniqueness. One is uniqueness in terms of the current model of a COW array vs uniqueness in the sense of a unique class. A unique class is a class that can never be copied.


-->

<!--
+
+This document contains a proposal to add three features into Swift:
+
+* No escaping arguments
+* Move only values
+* Move only types
+
+The general outline of our discussion will be:
+
+1. We begin by talking about how move only values are naturally represented in
+   SIL when in Ownership SSA (OSSA) form and how that affects how the feature
+   must be built.
+
+2. Then we will talk about how the structure of SILGen additionally restricts
+   our pathways towards bringing up this feature.
+
+3. We will then discuss a new technique Performance Copy Propagation that allows
+   the compiler to infer lifetimes for values based off of uses of a value. We
+   will show how we can take advantage of this technique to define a new
+   diagnostic pass called Diagnostic Copy Propagation that we can use as a
+   borrow checker.
+
+4. Using Diagnostic Copy Propagation, we will then show how we can use it to
+   bring up first a no escape argument feature, then move only values, and
+   finally move only types.
+
+## Introduction: Diagnostic Copy Propagation
+
+As a result of implementing Ownership SSA (OSSA) in SIL, the Swift compiler can
+now infer the lifetimes at compile time of loadable typed values based off of
+the SSA uses of that value. The inferred lifetimes are able to be statically
+verified by the compiler as being OSSA correct (1) and allows the compiler to
+guarantee theoretically minimal ARC traffic. This is done by finding all of the
+places where the value has lifetime ending uses (consuming uses) and then
+determining the appropriate places where a copy would be needed if a lifetime
+ending use is reachable from another lifetime ending use. These are exactly the
+places where a programmer would need to manually insert an explicit copy when
+using a move only type! Today we use this technique in an optimization pass
+called Performance Copy Propagation that given a value, ignores all current
+local copies, computes/inserts the minimal set of actual copies needed and
+deletes all of the old local copies. Lets take a look at some SIL examples to
+see how PCP works. Consider the following SIL:
+
+```
+class Klass {}
+
+sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
+bb0(%0 : @guaranteed $Optional<Klass>):
+  %1 = copy_value %0 : $Optional<Klass>
+  switch_enum %1 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)
+
+bb1(%2 : @owned $Klass):
+  %f = function_ref @myFoo2 : $@convention(thin) (@guaranteed SubKlass) -> ()
+  %3 = unchecked_ref_cast %2 : $Klass to $SubKlass                                      (B)
+  apply %f(%3) : $@convention(thin) (@guaranteed SubKlass) -> ()
+  destroy_value %3 : $Klass                                                             (C)
+  br bb3
+
+bb2:
+  br bb3
+
+bb3:
+  %9999 = tuple()
+  return %9999 : $()
+}
+```
+
+PCP as it runs visits the transitive def-use graph rooted at ``%0`` looking
+through uses that forward ownership from their operands to results ((A),
+(B)). It sees that the only true consuming use of %0 is actually the
+`destroy_value` (C) and additionally that all of the forwarding uses are able to
+take a guaranteed value meaning no copies are needed. It then converts the SIL
+to use guaranteed values and eliminates all of the old copies, yielding the
+following SIL:
+
+```
+sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
+bb0(%0 : @guaranteed $Optional<Klass>):
+  switch_enum %0 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)
+
+bb1(%1 : @guaranteed $Klass):
+  %f = function_ref @myFoo2 : $@convention(thin) (@guaranteed SubKlass) -> ()
+  %2 = unchecked_ref_cast %1 : $Klass to $SubKlass                                      (B)
+  apply %f(%2) : $@convention(thin) (@guaranteed SubKlass) -> ()
+  br bb3
+
+bb2:
+  br bb3
+
+bb3:
+  %9999 = tuple()
+  return %9999 : $()
+}
+```
+
+Lets now consider a case where we actually need a copy due to a consuming use:
+
+```
+sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
+bb0(%0 : @guaranteed $Optional<Klass>):
+  %1 = copy_value %0 : $Optional<Klass>
+  switch_enum %1 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)
+
+bb1(%2 : @owned $Klass):
+  %f = function_ref @myFoo2 : $@convention(thin) (@owned SubKlass) -> ()
+  %3 = unchecked_ref_cast %2 : $Klass to $SubKlass                                      (B)
+  apply %f(%3) : $@convention(thin) (@owned SubKlass) -> ()                             (C)
+  br bb3
+
+bb2:
+  br bb3
+
+bb3:
+  %9999 = tuple()
+  return %9999 : $()
+}
+```
+
+In this case, PCP will again ignore the ``copy_value`` in ``%1`` and will
+compute directly from the uses that a copy is needed at (C). But it will see
+that it is only needed in bb1, not along bb2. So it will insert a copy_value at
+(C) and then eliminate the ``copy_value``, yielding the following SIL:
+
+```
+sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
+bb0(%0 : @guaranteed $Optional<Klass>):
+  switch_enum %1 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)
+
+bb1(%2 : @guaranteed $Klass):
+  %f = function_ref @myFoo2 : $@convention(thin) (@owned SubKlass) -> ()
+  %3 = unchecked_ref_cast %2 : $Klass to $SubKlass                                      (B)
+  %4 = copy_value %3 : $SubKlass
+  apply %f(%4) : $@convention(thin) (@owned SubKlass) -> ()                             (C)
+  br bb3
+
+bb2:
+  br bb3
+
+bb3:
+  %9999 = tuple()
+  return %9999 : $()
+}
+```
+
+As a final case, lets consider a situation where we need multiple copies:
+
+```
+sil [ossa] @myFunc : $@convention(thin) (@guaranteed Klass) -> () {
+bb0(%0 : @guaranteed $Optional<Klass>):
+  %1 = copy_value %0 : $Optional<Klass>
+  switch_enum %1 : $Optional<Klass>, case #Optional.some: bb1, case #Optional.none: bb2 (A)
+
+bb1(%2 : @owned $Klass):
+  %f = function_ref @myFoo2 : $@convention(thin) (@owned SubKlass) -> ()
+  %3 = unchecked_ref_cast %2 : $Klass to $SubKlass                                      (B)
+  apply %f(%3) : $@convention(thin) (@owned SubKlass) -> ()                             (C)
+  br bb3
+
+bb2:
+  br bb3
+
+bb3:
+  %9999 = tuple()
+  return %9999 : $()
+}
+```
+
+One part of the discussion below is the proposal to take advantage of this to
+create a new diagnostic pass based off of the same infrastructure as
+"performance copy propagation" (PCP), but instead of inserting copies, emits a
+diagnostic that tells the user about why the copy was needed and as a fixit,
+where the copy needs to be inserted. This would then make it very easy for the
+programmer to insert an explicit copy if needed and go on with their day. This
+theoretical pass I am going to refer to as "Diagnostic Copy Propagation" (DCP).
+
+
+
+(1) Ownership SSA correct means that the loadable value is guaranteed to never
+be consumed twice, leaked, and all uses of the value are within the OSSA
+lifetime.
+
+----
+
+Attendees: TimK, JohnMc, JoeG, DougG, MichaelG
+
+DougG, JohnMc brought up that the two parts of concurrency that overlap are unique classes and mutable if unique classes.
+
+MichaelG then laid out the discussions that we have been having. He first brought up the overall plan that we have been discussing in the Swift performance team:
+
+1. Begin with No Escape Parameters
+2. Then do Unique Values/Unique Values
+3. Then with time do Unique Types
+
+We will go through the individual discussions below on each section. Some context information is included above those other sections in order to provide context for the reader. Also note that we are assuming that we are working in a world where opaque values exist, so we do not need to worry about handling address only types.
+
+Context: Diagnostic Copy Propagation
+
+
+No Escape Parameters
+
+#### Design
+
+The overall proposal here was to allow for no-escape to be added to all parameters (instead of just function types). This would be implemented by adding a new diagnostic pass that would:
+
+1. Emit an error diagnostic whenever a non-escape parameter was stored into memory.
+2. Allow for trivial parameters to be passed to anything. There is no reason to restrict no escape parameters of trivial values since they are passed by value.
+3. For non-trivial parameters, use a form of diagnostic copy propagation to perform the diagnostic. An owned non-trivial value will only be considered to escape if there are multiple consuming uses along the same path of the non-trivial value implying a copy would have been needed and would escape. A guaranteed non-trivial value is likewise only considered to escape if copy propagation found any consuming uses and wanted to insert copies for them. This would enable us to give really nice diagnostics that show the user what caused the escaping use. Additionally we would only allow for this value to be passed as no escape parameters.
+
+#### Response
+
+The end response from the group was that this was a sound idea that we want to pursue as part of this effort.
+
+There were some questions around if we needed to use diagnostic copy propagation/connect this directly with move only value implementation. It was noted that we want no-escape to also work for trivial values like UnsafePointer. We want to prevent people from escaping these pointers from withUnsafePointer closures. The design here will need to be modified to take this into consideration. JohnMc and MikeG agreed that this would just mean a diagnostic pass that looked at uses which is really standard/simple. We would then just loosen the rules over time as people use the feature and we find patterns for trivial types that we are ok with. We could do something similar for non-trivial values by just doing the standard thing in these types of passes: looking through copies as we walk from def→use. We would require that the value is passed only as a no-escape function argument, providing a transitive guarantee. The author (MikeG) thinks this pass design is reasonable and is pretty standard/easy thing to do with a transitive def→use traversal. We also may want to consider adding a way to escape the ‘prison’ for library writers. I think it would just be a node on the def→use traversal.
+
+We also spoke about how this composes with move only values vs unique values. JohnMc noted that a unique value and a move only value behave differently in this model. I talk about it below in the section around move only values/unique values since I believe we were actually talking about different notions of “unique”.
+
+*Conclusion*: But overall, we agreed it was a diagnostic pass that we believe that we could write easily and that it would be useful to people.
+
+*From The Author:* Thanks JohnMc for the great discussion! Part of the reason that the author brought up no escape parameters, was that he thought it would help us prove that copy propagation can be used as a diagnostic in a simpler situation than with move only values. The author was trying to come up with a design program that would help us tip-toe our toes into using copy propagation for diagnostics for the first time! That being said, the escape analysis thing is still something we should do and our users will be notice it!
+
+Unique Values and Unique Value
+
+As a quick online of this section, I start by describing the design from the SIL level up and hopefully show how SIL level constraints pushes us towards a certain design for move only values. Then I will show how I can use Ownership SSA and Diagnostic Copy Promotion to avoid us needing to do a large update to SILGen. Then, I will talk about how we can handle trivial move only types by using an introducer and conclude by talking about how unique types can fit into all of this/how they are different than COW uniqueness (but complementary).
+
+The natural way to represent a move only value in SIL is as a non-trivial loadable value that can not be copied with a normal copy_value. This is because in SIL the notion of being copied is inherently tied to a value being non-trivial since we do not track ownership for trivial values. The ownership of the non-trivial value flows through the entire SIL program via the def→use graph and thus we can write a diagnostic pass based off of copy propagation to infer if a copy is needed somewhere in the program and give a fixit to the user at that spot to insert an explicit copy if they want:
+
+sil @move_only : $@convention(thin) (@owned @move Klass, @guaranteed @move Klass) -> () {
+bb0(%0 : @owned @move Klass, %1 : @guaranteed @move Klass):
+  // Safe, can never be copied.
+  apply %f(%0) : $@convention(thin) (@guaranteed @move Klass) -> ()
+  // This is an explicit copy that copy propagation left alone. We treat it as
+  // a TrivialUse (meaning an ignorable one) that produces an owned value.
+  %3 = explicit_copy %0
+  // Error! Diagnostic constant propagation says we need a copy here.
+  // Display fixit telling the user that a copy is needed here due to use at SourceLoc()
+  apply %f2(%1) : $@convention(thin) (@owned @move Klass) -> ()
+  // No error, we are passing off our value, moving it.
+  apply %f3(%0) : $@convention(thin) (@owned @move Klass) -> ()
+  // Error! Diagnostic Propagation knows %0 was already destroyed by %f2. We 
+  // emit as part of the fixit that we need to put our copy before the call to %f3.
+  apply %f4(%0) : $@convention(thin) (@owned @move Klass) -> ()
+}
+
+This model will make the life of programmers easier since we are not just throwing an error, we are also telling them actionable information to fix the issue!
+
+This looks pretty, but as anyone who has worked in SILGen will tell you, SILGen loves to insert copies! In fact often times SILGen will assume that a value is at +0 to conditionally run at all. All of those places would need to be fixed and it would take time to do so. We could do that 
+
+That all looks nice and good, but as anyone who has worked in SILGen will tell you, SILGen loves to insert copies and a lot of code triggers off of whether or not one is tracking a copy or not. Updating SILGen to support move only types out of the gate will be a lot of work and will require reimplementing/modifying a bunch of SILGen. This is something we can do, but it would be a significant amount of work. Instead, we propose that we:
+
+1. Require move only values to be non-trivial
+
+
+The author 
+
+in SIL a move only type should naturally be represented as a non-trivial loadable value. By using the information in Ownership SSA, we can easily infer if/where a copy would be needed just based off of the uses of the value. This information is only based off the uses.
+
+for loadable non-trivial values, a class is a very fundamental type. Beyond a class, only class bound protocols are loadable (with time address only types will be as well.. but that is once opaque values lands).
+
+Thus if one wanted to design a notion of a move only type in SIL, it is natural to want to build it on top of non-trivial loadable unique types which are defined as values whose class fields are all unique classes. This would ensure that one could move around the class parts as a move only value and preserve the uniqueness of memory. It flows well with how SIL would want to represent these, as aggregate values. 
+
+a unique class is a class that can never be copied, it can only be moved.
+
+In the SIL type system classes are a foundational type of non-trivial type but there are others. For now since we are assuming that we will not allow for this on generic types until opaque values lands so one will not be able to use this with generics since we specialize code at the SIL level. So, thus any value we are talking about right now are loadable values. Then define a unique loadable value as a non-trivial loadable value that only contains unique non-trivial values. In this model, one would be able to move the value around as a move only value just as if one had a class ensuring that all of the memory structurally is unique. Even better, by taking advantage of Ownership SSA and Diagnostic Copy Propagation, we would be able to emit good diagnostics that explain to the user why the copy is needed and can provide a fixit at the appropriate place in the code where the copy would be needed. This would make working with this system much easier for the programmer. We could also identify explicit copies that were unneeded and provide a fixit to remove the copy. This will create a model where the compiler helps the user work with their code explicitly based off of the uses of the program.
+
+The author then said, well we could bootstrap 
+
+Specifically, a unique value is /ok/ with being copied as long as before the function ends the value is again unique. So in a sense the move only condition is a stronger condition on the def→use graph than the unique condition on values. The author believes upon reflection that the truth is that we were talking about two different forms of uniqueness. One is uniqueness in terms of the current model of a COW array vs uniqueness in the sense of a unique class. A unique class is a class that can never be copied.
+
+

-->
